# ЛР 3. Интеграция шаблонов с бизнес-логикой и server-sent events

Целью данной лабораторной работы является реализация полноценного многостраничного приложения с использованием шаблона проектирования MVC и принципов DDD. Выполнение работы разбивается на несколько этапов:

1. Верхнеуровневое проектирование системы;
2. Описание контроллеров, реализация базовой бизнес-логики и адаптация шаблонов;
3. Интеграция server-sent events в один из шаблонов.

## Проектирование системы

На этом этапе требуется описать взаимосвязь поддоменов, выявленных в ЛР 2. В NestJS за реализацию каждого поддомена отвечает тот или иной [модуль](https://docs.nestjs.com/modules), включающий в себя все необходимые контроллеры, сервисы, сущности и т.п.

> [!WARNING]
> Не нужно выносить абсолютно все контроллеры в одну папку, все сервисы в другую папку и т.д., это противоречит идее DDD.

Модули можно сгенерировать консольной командой самого NestJS:

```bash
nest generate resource [name] --no-spec
```

Эта команда сгенерирует не только сам модуль, но и сопутствующие классы. Флаг `--no-spec` отключит создание файлов для тестов (их при желании можно добавить позже). Подробнее про команду и её возможности можно почитать [в документации](https://docs.nestjs.com/recipes/crud-generator).

Например, если сгенерировать ресурс `posts`, создастся следующая файловая структура:

```text
posts
├── dto
│   ├── create-post.dto.ts
│   └── update-post.dto.ts
├── entities
│   └── post.entity.ts
├── posts.controller.ts
├── posts.module.ts
└── posts.service.ts
```

Если согласиться на предложение утилиты создать CRUD-операции, то контроллер и сервис будут содержать заготовку пяти соответствующих методов (но напоминаем, что пока что мы делаем не API, а многостраничное веб-приложение, т.е. контроллеры нужно будет дополнить).

После создания модулей их нужно связать для корректной работы DI фреймворка, почитать про это тоже можно в документации.

## Контроллеры, сервисы и представления

После создания модулей их нужно реализовать. В зависимости от выбранного домена наполнение контроллеров будет разным, но предполагается, что как минимум будут реализованы стандартные CRUD-операции:

* Просмотр всей коллекции (`GET /posts`);
* Просмотр одной сущности из коллекции (`GET /posts/:id`);
* Создание новой сущности (`POST /posts`);
* Изменение существующей сущности (`PATCH /posts/:id`);
* Удаление существующей сущности (`DELETE /posts/:id`).

Если вы генерировали модули командой выше, то шаблон контроллера уже содержит эти операции, их нужно только подвязать к шаблонам при необходимости. При этом в корневом модуле фактически не должно остаться кода, отвечающего за выделенные поддомены, максимум, что можно там оставить - некоторые общие эндпоинты и бизнес-логику, например, главную страницу и шаблоны, не относящиеся к поддоменам (например, конструктор из прошлого семестра).

При создании, изменении или удалении сущности нужно перенаправить пользователя либо на страницу с сущностью, либо на страницу с коллекцией. Для форм создания или изменения сущностей сделайте отдельные страницы (например, `GET /posts/add` и `GET /posts/:id/edit`).

Также реализуйте бизнес-логику в сервисах для обработки этих запросов. В рамках лабораторных работ от вас не требуется реализовать полноценное приложение с использованием DDD, но хотя бы не пишите бизнес-логику в контроллерах.

Последнее, что нужно сделать: написать новые шаблоны и изменить уже существующие таким образом, чтобы они корректно взаимодействовали с написанными контроллерами и сервисами (т.е. нужно сделать так, чтобы страница с просмотром постов показывала посты из базы данных, а форма создания поста сохраняла его не в local storage, а в базу данных). Если вы не выделили общую структуру страницу как отдельный [layout](https://stackoverflow.com/questions/51845556/how-to-set-up-a-default-layout-in-nest-js-using-handlebars-js), то это нужно сделать, чтобы не писать одну и ту же шаблонную разметку много раз.

## Обработка данных в режиме реального времени с помощью Server-sent events

Последним пунктом ЛР является добавление оповещения об изменении сущности в какой-либо коллекции на ваше усмотрение в режиме реального времени. В этот раз вместо веб-сокетов (WS) нужно будет использовать механизм server-sent events (SSE). Он проще веб-сокетов и в большинстве случаев покрывает сценарии использования, для которых по традиции веб-сокеты и берут.

Чтобы начать работу с SSE, в контроллере нужной сущности создайте новый эндпоинт с декоратором `@Sse()`. Поскольку здесь для работы используются концепции реактивного программирования (метод контроллера должен вернуть Observable-поток), ознакомьтесь [с документацией по библиотеке RxJS](https://www.learnrxjs.io/learn-rxjs/operators/transformation), прежде чем пытаться написать какой-то код [по рецепту из документации фреймворка](https://docs.nestjs.com/techniques/server-sent-events) и [примеров со StackOverflow](https://stackoverflow.com/questions/67202527/can-we-use-server-sent-events-in-nestjs-without-using-interval).

После реализации SSE на сервере нужно реализовать поддержку обновлений на клиенте. Для этого воспользуйтесь классом `EventSource`, предварительно почитав [документацию на MDN](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events). Обновления нужно показывать на самой странице (простого `console.log()` недостаточно), для этого можно взять библиотеку toster.js.

![pic](https://i.imgur.com/MuXW2Wq.png)
