# ЛР 4. Разработка RESTful API и его спецификации

В результате выполнения данной лабораторной работы должна быть получена спецификация RESTful API, содержащая все необходимые методы для работы с ранее созданной моделью, и разработана реализация этих методов.

## Реализация контроллеров

Для выполнения работы необходимо создать в ранее созданных модулях новые контроллеры, отвечающие за реализацию именно API (после третьей ЛР у вас есть контроллеры, отвечающие за MVC). Генерировать отдельный контроллер с нестандартным названием с помощью командной строки неудобно, поэтому предлагается вручную создать файл и написать в нём класс. Пример такой заготовки:

```ts
import { Controller } from '@nestjs/common';

@Controller('api/posts')
export class PostsApiController {
    // Здесь укажите маршруты
}
```

В конструкторе контроллеров нужно указать используемые сервисы как зависимости. В прошлой лабораторной это было сделано при генерации модуля, сейчас это также нужно сделать вручную, для этого изучите, как это сделала утилита.

Опишите внутри контроллера варианты использования в виде конечных точек (endpoints), соблюдая [принципы REST](https://restfulapi.net/), в частности правила именования и использования HTTP-методов. Если сущность имеет связи с другими сущностями (например, комментарии связаны с постом в блоге), то должна быть возможность получить дочерние сущности из родительской (как все сущности, так и конкретную).

Следующим шагом необходимо убедиться на уровне контроллера в том, что передаваемые данные (как параметры, так и тело запроса) являются корректными с точки зрения схемы данных. Можно это проверять в самих контроллерах, но более разумным и правильным вариантом будет использование встроенных возможностей NestJS (класс `ValidationPipe`), который может автоматически как проверить поля пришедшего объекта по заданным правилам, так и конвертировать данные в нужный формат (например, строку в число). Для этого нужно прочитать соответствующий [раздел документации](https://docs.nestjs.com/techniques/validation). При ошибке в передаваемых данных от сервера ожидается ответ `HTTP 400 Bad Request`.

Реализуйте обработку исключений на уровне приложения с помощью отдельного класса [`ExceptionFilter`](https://docs.nestjs.com/exception-filters). Это позволит одинаково обрабатывать одни и те же исключения вне зависимости от того, где они возникли (например, если исключение было выброшено используемой ORM-библиотекой).

При просмотре всей коллекции доставать непосредственно все объекты - не самая хорошая идея: возникнут проблемы с производительностью и объёмом передаваемых данных. Чтобы такого не было, реализуйте пагинацию. Чтобы ваше API было ближе к HATEOAS, передавайте ссылки на предыдущую и следующую страницы, это можно сделать [с помощью заголовка ответа `Link`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Link#pagination_through_links).

## Доработка бизнес-логики

После реализации контроллеров нужно реализовать сервисы, которые будут выполнять основную бизнес-логику. Скорее всего, большая часть логики была реализована в рамках прошлой лабораторной, поэтому можно доработать то, что есть, и дописать новые методы, при этом не должна нарушиться работа многостраничного приложения. Например, если при получении сущности она не нашлась, то MVC должно вернуть HTML-страницу с сообщением, а API - ответ в формате JSON со статусом `HTTP 404 Not Found` (в идеале такой статус должен возвращаться и у HTML-страницы).

Из сервисов можно (и нужно) возвращать HTTP-ответы с заданным статусом с помощью выбрасывания [определённых исключений](https://docs.nestjs.com/exception-filters#built-in-http-exceptions), это помогает не захламлять код лишним выбрасыванием своих исключений и их обработкой в контроллерах или фильтре исключений.

## Создание спецификации формата OpenAPI и подключение Swagger

После реализации API нужно создать его документацию в формате OpenAPI. NestJS умеет генерировать документацию с использованием Swagger автоматически, ориентируясь на специальные декораторы, подробнее про которые можно почитать в соответствующем [разделе документации](https://docs.nestjs.com/openapi/introduction). Предполагается, что вы уже знаете, что такое Swagger :)

При создании документации сделайте так, чтобы один тег соответствовал одному модулю:

![](https://i.imgur.com/diqOaqh.png)

У конечных точек должно быть описание структуры тела запроса (если это не GET-запрос), описание структуры ответа, перечисление возможных кодов статуса HTTP (не только `HTTP 200 OK` и `HTTP 404 Not Found`). Тело запроса и ответа описывается с помощью отдельных классов, которые также продекорированы соответствующим образом. Если вы используете Prisma, советуем почитать [документацию по её генераторам](https://www.prisma.io/docs/orm/prisma-schema/overview/generators), один из них позволяет сгенерировать по схеме DTO с декораторами.

Всё это нужно для повышения читабельности и понятности документации, то есть не должно быть ситуаций, когда возникает вопрос "Какие данные нужно передать?" или "Что я могу получить в ответ?", в противном случае клиентам нужно будет обращаться к вам как к разработчику, что указывает на недостаточно полное проектирование API.
