# ЛР 2. Создание доменной модели и её описание

В результате выполнения лабораторной работы должна быть спроектирована и реализована модель данных, описывающая выбранную прикладную область. Как и в прошлый раз, работа состоит из двух частей: развёртывание и реализация.

## Развёртывание реляционной СУБД

Для выполнения данной лабораторной работы вам необходимо выбрать поставщика услуг уровня баз данных. Рекомендуется воспользоваться любым Database as a Service решением, либо можете использовать реляционную СУБД на любом выделенном сервере. Здесь мы рассмотрим два варианта: DBaaS на самом Render и на Aiven.

NB: размещать СУБД в виде SQLite-файла рядом с приложением не стоит, поскольку Render не обеспечивает сохранение добавленных и изменённых файлов после повторного развёртывания.

### PostgreSQL на Render

Чтобы использовать базу данных PostgreSQL в качестве СУБД, необходимо выбрать соответствующий пункт в Dashboard-панели хостинга Render:

![](https://i.imgur.com/OossYbT.png)

**Обратите внимание**, что Render предоставляет бесплатный доступ к СУБД в ознакомительном режиме. Созданная база данных будет существовать **один месяц**, после чего станет недоступна и через некоторое время будет удалена. Остальные ограничения можно посмотреть в [соответствующем разделе документации](https://render.com/docs/free#free-postgres).

С этим можно бороться, периодически экспортируя БД и потом восстанавливая её. Для этого понадобятся две утилиты, `pg_dump` и `pg_restore`. Они обе доступны в случае полной установки PostgreSQL на локальный компьютер (не на сервер СУБД).

В случае Windows достаточно скачать стандартный установщик и в нём при выборе компонентов оставить только Command Line Tools:

![](https://i.sstatic.net/vwljN.png)

Для остальных систем:

```sh
# Для Debian-based
sudo apt install postgresql-client

# Для RHEL-based
sudo dnf install postgresql

# Для MacOS с Homebrew
brew install libpq
brew link --force libpq
```

После этого можно делать дампы и восстанавливать БД, используя плагин для WebStorm (про него ниже).

Параметры создания базы данных, предложенные мастером настройки, можно не менять, пользователь и название самой базы будет сгенерировано автоматически. Если вы хотите что-то изменить, это можно сделать согласно [документации](https://render.com/docs/databases), представленной хостингом.

После создания экземпляра СУБД вам будет предоставлено две ссылки: 

- Internal Database URL, который вы должны использовать непосредственно в задеплоенном на Render приложении;
- External Database URL, который вы можете использовать для подключения со своей локальной машины.

![](https://i.imgur.com/SPXdmai.png)

### PostgreSQL на Aiven

В качестве более простой альтернативы (без повторной настройки каждый месяц) можно использовать сервис [Aiven](https://aiven.io/free-postgresql-database).

На нём нужно зарегистрироваться (для удобства можно через GitHub, например) и зайти в консоль. Вам предложат создать организацию с бесплатным пробным периодом. Обратите внимание, что только одна организация может быть подключена к бесплатному плану, остальные (даже если удалить первую) будут без такой возможности.

После создания организации создайте сервис с БД:

![](https://i.imgur.com/VlInCTj.png)

При создании нужно будет выбрать Free plan и по возможности тот же регион, в котором находится приложение на Render. Если вы делали прошлую лабу по инструкции, то это будет Франкфурт (do-fra).

После создания Aiven покажет информацию для подключения, в том числе и URI для подключения:

![](https://i.imgur.com/rSDS7rR.png)

Поскольку БД будет на внешнем по отношению к Render хосте, и для подключения с локального компьютера, и для развёртывания приложения на Render нужно будет использовать одну ссылку.

### Проверка подключения и настройка приложения

Проверьте, что вы можете подключиться к созданной базе данных. 

Рекомендуется использовать встроенный в WebStorm инструмент, дублирующий функционал DataGrip. По умолчанию он не включен в дистрибутив, поэтому установите пакет из маркетплейса самостоятельно.

![](https://i.imgur.com/hJDkjpU.png)

Для подключения нужно добавить новый источник данных и в нём указать нужные параметры конфигурации. Если всё указано верно, то тестирование подключение выполнится успешно:

![](https://i.imgur.com/3xUDEvs.png)

Если у вас получилось получить сообщение, что подключение успешно установлено, можно переходить к следующему шагу — подключению СУБД к вашему проекту.

Первым делом, необходимо добавить Connection String как переменную среды окружения для вашего приложения. Для этого зайдите в раздел **Environment** и создайте ключ `DATABASE_URL` как на изображении ниже:

![](https://i.imgur.com/b9EU4d4.png)

Значение для этого ключа скопируйте из поля "Internal Database URL".

Также добавьте соответствующий External Database URL для локальной конфигурации в ваш проект как на скриншоте ниже:

![](https://i.imgur.com/NiZ6SXY.png)

В качестве альтернативы для локальной разработки можно поднять СУБД локально (например, в Docker-контейнере) и указать соответствующие параметры окружения.

Так как используется Postgres, то необходимо добавить пакет `pg` как зависимость (`pg` — это ODBC для Node.js):

```sh
npm install pg --save
```

Далее необходимо выбрать одну из поддерживаемых ORM для работы со слоем данных. Рекомендуется либо TypeORM, либо Prisma.

Если вы используете TypeORM, вам понадобится распарсить connection string к базе данных и предоставить её ORM в том виде, как это описано в документации, в виде отдельных полей: `host`, `username`, `password` и т.д. 

Для решения этой задачи рекомендую воспользоваться NPM-пакетом `pg-connection-string`. Ознакомьтесь с разделом [Async Configuration](https://docs.nestjs.com/techniques/database#async-configuration) и реализуйте сервис инфраструктурного слоя DDD для создания объекта, необходимого ORM для подключения.

Если вы используете Prisma, то connection string можно использовать as-is. В качестве инфраструктурного слоя необходимо создать файл `schema.prisma` и добавить в него указания поставщика и названия ключа переменной окружения - `env(DATABASE_URL)`. Для Prisma также нужно создать специальный инфраструктурный сервис [по рецепту из документации Nest.js](https://docs.nestjs.com/recipes/prisma#install-and-generate-prisma-client).

## Описание домена и моделей

После подключения ORM необходимо описать все модели необходимые для работы вашего проекта. Рекомендуется описывать сущности согласно DDD с использованием общего языка выбранной предметной области. Обратите внимание, что в домене нужно выделить минимум 5 разных сущностей, связанных между собой.

На примере `UserModule` из лекционного материала, если вы создаёте модуль для работы с пользователем, то выделяйте сущности по смыслу в отдельные директории (`src/%moduleName%/entities/%entityName%.entity.ts`).

![](https://i.imgur.com/XEqNUlN.png)

Чтобы ваши сущности были обработаны TypeORM, необходимо добавить декоратор [`@Entity`](https://docs.nestjs.com/techniques/database#repository-pattern) согласно документации. 

Для Prisma схема объявляется в отдельном файле [согласно документации](https://docs.nestjs.com/recipes/prisma#create-two-database-tables-with-prisma-migrate). В этом случае сущности для генерации схемы объявлять не нужно, поскольку они вместе с клиентом будут сгенерированы из описанной схемы.

И для TypeORM, и для Prisma настоятельно рекомендуется использовать механизм миграций, который позволит инкрементально обновлять схему БД. Для Prisma будет полезен фрагмент соответствующего [рецепта](https://docs.nestjs.com/recipes/prisma#create-two-database-tables-with-prisma-migrate), а для TypeORM нужно будет почитать [раздел документации](https://typeorm.io/migrations#creating-a-new-migration).

Сгенерируйте визуальное представление схемы вашей данных в виде ER-диаграммы и экспортируйте его в файл:

![](https://i.imgur.com/V3TpUVO.png)

![](https://i.imgur.com/Ma1WCsp.png)

Пример диаграммы в DataGrip представлен ниже:

![](https://i.imgur.com/F7L0FZK.png)

Полученную схему в виде ER-диаграммы загрузите в корень вашего репозитория и разместите в файле `README.md` вместе с текстовым описанием доменной области и выделенных сущностей.
